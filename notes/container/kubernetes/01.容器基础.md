> 容器本身没有价值，有价值的是“容器编排”

## 容器，到底是怎么一回事儿？

​	容器其实就是一种沙盒技术。顾名思义，沙盒就是能够像一个集装箱一样，把开发的应用“装”起来的技术。这样应用与应用之间就因为有了边界而不至于相互干扰。而被装进集装箱的应用，也可以被方便地搬来搬去，这不就是PaaS最理想的状态嘛

### 进程

​	程序（代码的可执行镜像）被执行起来，它从磁盘的二进制文件变成了计算机内存中的数据、寄存器里的值、堆栈中的指令、被打开的文件，以及各种设备的状态信息的一个集合。像这样一个程序运行起来后的计算机执行环境的总和，称为操作系统的进程

​	对于进程而言，它的静态表现就是程序，平常都安安静静地待在磁盘上；而一旦运行起来，它就变成了计算机里的数据和状态的总和，这就是它的动态表现。

### 容器技术核心功能

#### 通过约束和修改进程的动态表现，从而为其创造出一个“边界”

* Cgroups技术是用来制造约束的主要手段

* Namespace技术是用来修改进程视图的主要手段

  通过Linux系统本质来理解这两项技术

  尝试创建一个容器

  ~~~bash
  # docker run -it busybox /bin/sh
  / # 
  ~~~

  在容器中执行ps指令

  ~~~bash
  / # ps
  PID   USER     TIME  COMMAND
      1 root      0:00 /bin/sh
      6 root      0:00 ps
  / #
  ~~~

  在宿主机执行ps指令

  ~~~bash
  # ps
    PID TTY          TIME CMD
   4836 pts/0    00:00:00 su
   5136 pts/0    00:00:00 bash
   6471 pts/0    00:00:00 sh
   6814 pts/0    00:00:00 ps
  ~~~

  可以看出Docker里最开始执行的/bin/sh，就是这个容器内部的第1号进程，而这个容器里一共只有两个进程在运行。同时宿主机上对应的容器运行的进程号为6471，Docker已经与宿主机进行了完全的隔离。这种机制，其实就是对被隔离的应用的进程空间做了手脚，使得这些进程只能看到重新计算过的进程编号。实际上在宿主机的操作系统里，还是原来的第6471进程。这种技术就是Linux里面的Namespace机制

  Linux系统中创建线程的系统调用是clone()

  ~~~bash
  int pid = clone(main_function, stack_size, SIGCHLD, NULL); 
  ~~~

  利用Linux调用clone创建新进程时，在一个可选参数中指定CLONE_NEWPID 参数

  ~~~bash
  int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL); 
  ~~~

  这时新创建的进程将会“看到”一个全新的进程空间，在这个进程空间里它的PID就是1

  除了上述的PID Namespace，Linux操作系统还提供了Mount、UTS、IPC、Network和User等Namespace，用来对各种不同的进程上下文进行“障眼法”操作

  ​	Mount Namespace：用于让被隔离进程只看到当前Namespace里的挂载点信息

  ​	Network Namespace：用于让被隔离进程只看到当前Namespace里的网络设备和配置

  上述就是Linux容器最基本的实现原理。所以说，**容器**，其实是一种特殊额进程而已