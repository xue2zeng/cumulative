> 容器本身没有价值，有价值的是“容器编排”

## 容器，到底是怎么一回事儿？

​	容器其实就是一种沙盒技术。顾名思义，沙盒就是能够像一个集装箱一样，把开发的应用“装”起来的技术。这样应用与应用之间就因为有了边界而不至于相互干扰。而被装进集装箱的应用，也可以被方便地搬来搬去，这不就是PaaS最理想的状态嘛

### 进程

​	程序（代码的可执行镜像）被执行起来，它从磁盘的二进制文件变成了计算机内存中的数据、寄存器里的值、堆栈中的指令、被打开的文件，以及各种设备的状态信息的一个集合。像这样一个程序运行起来后的计算机执行环境的总和，称为操作系统的进程

​	对于进程而言，它的静态表现就是程序，平常都安安静静地待在磁盘上；而一旦运行起来，它就变成了计算机里的数据和状态的总和，这就是它的动态表现。

### 容器技术核心功能

#### 通过约束和修改进程的动态表现，从而为其创造出一个“边界”

* Cgroups（Control groups）技术是用来制造约束的主要手段

  主要作用就是限制一个进程组能够使用的资源上线，包括CPU、内存、磁盘、网络宽带等

  Cgroups给用户暴露出来的操作接口是文件系统，即它以文件和目录的方式组织在操作系统的/sys/fs/cgroup路径下

  ~~~bash
  # mount -t cgroup
  cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)
  cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,perf_event)
  cgroup on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,pids)
  cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,cpuacct,cpu)
  cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,net_prio,net_cls)
  cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,memory)
  cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,blkio)
  cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,devices)
  cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,hugetlb)
  cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,cpuset)
  cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,freezer)
  ~~~

  以CPU子目录（子系统）来说

  ~~~bash
  # ls /sys/fs/cgroup/cpu
  cgroup.clone_children  cgroup.procs          cpuacct.stat   cpuacct.usage_percpu  cpu.cfs_quota_us  cpu.rt_runtime_us  cpu.stat  notify_on_release  system.slice  user.slice
  cgroup.event_control   cgroup.sane_behavior  cpuacct.usage  cpu.cfs_period_us     cpu.rt_period_us  cpu.shares   release_agent      tasks
  ~~~

  在该目录下创建一个目录，这个目录就称为一个“控制组”。操作系统会在新建的container目录下自动生成该子系统对应的资源限制文件

  ~~~bash
  # mkdir container
  # ls
  cgroup.clone_children  cgroup.procs  cpuacct.usage         cpu.cfs_period_us  cpu.rt_period_us   cpu.shares  notify_on_release
  cgroup.event_control   cpuacct.stat  cpuacct.usage_percpu  cpu.cfs_quota_us   cpu.rt_runtime_us  cpu.stat    tasks
  ~~~

  执行如下脚本，可以把计算机的CPU吃到100%，根据它的输出可以看到这个脚本在后台的进程号（PID）是23378

  ~~~bash
  # while : ; do : ; done &
  [1] 23378
  # top
  %Cpu0 :100.0 us, 0.0 sy, 0.0 ni, 0.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st
  ~~~

  通过查看container目录下的文件，看到container控制组里的CPU quota还没有任何限制（即：-1），CPU period则是默认的100ms（100000us）

  ~~~bash
  # cat /sys/fs/cgroup/cpu/container/cpu.cfs_quota_us 
  -1
  # cat /sys/fs/cgroup/cpu/container/cpu.cfs_period_us 
  100000
  ~~~

  通过修改这些文件的内容来设置限制。向container组里的cfs_quata文件写入20ms（20000us），把被限制的进程的PID写入container组里的tasks文件，上面的设置就会对该进程生效

  ~~~bash
  # echo 20000 > /sys/fs/cgroup/cpu/container/cpu.cfs_quota_us
  # echo 23378 > /sys/fs/cgroup/cpu/container/tasks 
  # top
  %Cpu0 : 20.3 us, 0.0 sy, 0.0 ni, 79.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st
  ~~~

  对于Docker等Linux容器来说，它们只需要在每个子系统下面为每个容器创建一个“控制组”（即创建一个新目录），然后在启动容器进程之后，把这个进程的PID填写到对应控制组的tasks文件中就可以了。控制组下面的资源文件里面填上什么值，就靠用户执行docker run时的参数来指定

  ~~~bash
  # docker run -it --cpu-period=100000 --cpu-quota=20000 busybox /bin/bash
  # cat /sys/fs/cgroup/cpu/docker/3c345c23e033a387841e2903a509ba888b8f11cfed8218268204f2b11d8a6f4f/cpu.cfs_period_us 
  100000
  # cat /sys/fs/cgroup/cpu/docker/3c345c23e033a387841e2903a509ba888b8f11cfed8218268204f2b11d8a6f4f/cpu.cfs_quota_us 
  20000
  ~~~

  这就意味着这个Docker容器，只能使用到20%的CPU宽带

* Namespace技术是用来修改进程视图的主要手段

  通过Linux系统本质来理解这两项技术

  尝试创建一个容器

  ~~~bash
  # docker run -it busybox /bin/sh
  / # 
  ~~~

  在容器中执行ps指令

  ~~~bash
  / # ps
  PID   USER     TIME  COMMAND
      1 root      0:00 /bin/sh
      6 root      0:00 ps
  / #
  ~~~

  在宿主机执行ps指令

  ~~~bash
  # ps
    PID TTY          TIME CMD
   4836 pts/0    00:00:00 su
   5136 pts/0    00:00:00 bash
   6471 pts/0    00:00:00 sh
   6814 pts/0    00:00:00 ps
  ~~~

  可以看出Docker里最开始执行的/bin/sh，就是这个容器内部的第1号进程，而这个容器里一共只有两个进程在运行。同时宿主机上对应的容器运行的进程号为6471，Docker已经与宿主机进行了完全的隔离。这种机制，其实就是对被隔离的应用的进程空间做了手脚，使得这些进程只能看到重新计算过的进程编号。实际上在宿主机的操作系统里，还是原来的第6471进程。这种技术就是Linux里面的Namespace机制

  Linux系统中创建线程的系统调用是clone()

  ~~~bash
  int pid = clone(main_function, stack_size, SIGCHLD, NULL); 
  ~~~

  利用Linux调用clone创建新进程时，在一个可选参数中指定CLONE_NEWPID 参数

  ~~~bash
  int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL); 
  ~~~

  这时新创建的进程将会“看到”一个全新的进程空间，在这个进程空间里它的PID就是1

  除了上述的PID Namespace，Linux操作系统还提供了Mount、UTS、IPC、Network和User等Namespace，用来对各种不同的进程上下文进行“障眼法”操作

  ​	Mount Namespace：用于让被隔离进程只看到当前Namespace里的挂载点信息

  ​	Network Namespace：用于让被隔离进程只看到当前Namespace里的网络设备和配置

  上述就是Linux容器最基本的实现原理。所以说，**容器**，其实是一种特殊额进程而已