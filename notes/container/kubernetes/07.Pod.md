Pod：Kubernetes项目中最小的API对象，更专业的说法是原子调度单位

### Pod实现原理

基于容器的“单进程模型”，进程间存在着依赖问题。Kubernetes项目设计出了趋于调度上考虑的Pod

>容器的“单进程模型”，并不是指容器里只能运行“一个进程”，而是指容器没有管理多个进程的能力。这是因为容器里PID=1的进程就是应用本身，其他的进程都是这个PID=1进程的子进程。可是用户编写的应用，并不能够像正常操作系统里的init进程或是systemd那样拥有进程管理的能力

Pod在Kubernetes项目中更重要的意义：容器设计模式

Pod最重要的的一个事实：它只是一个逻辑概念，提供的是一中编排思想，而不是具体的技术方案。Kubernetes真正处理的还是宿主机操作系统上Linux容器的Namespace和Cgroups，而并不存在一个所谓的Pod的边界或者隔离环境。Pod其实就是一组共享了某些资源的容器（具体的说：Pod里的所有容器，共享的是同一个Network Namespace，并且可以声明共享同一个Volume）。

为了实现资源共享，在Kubernetes项目中使用一个叫作Infra的中间容器。在Pod中，Infra容器永远是第一个被创建的容器，而其他用户定义的容器，则通过Join Network Namespace的方式与Infra容器关联在一起。

![pod infra](./images/pod_infra.png)

在Kubernetes项目里，Infra容器一定要占用极少的资源，所以它使用的是一个非常特殊的镜像，叫作：k8s.gcr.io/pause，这个镜像是一个用汇编语言编写，用户处于“暂停”状态的容器。

对于Pod里的容器A和容器B来说：

* 它们可以直接使用localhost进行通信
* 它们看到的网络设备跟Infra容器看到的完全一样
* 一个Pod只有一个IP地址，也就是这个Pod的Network Namespace对应的IP地址
* 当然，其他的所有网络资源都是一个Pod一份，并且被该Pod中的所有容器共享
* Pod的生命周期只跟Infra容器一致，而与容器A和B无关

容器设计模式最常用的一种模式叫sidecar（组合）

sidecar指的就是在一个Pod中，启动一个辅助容器来完成一些独立于主进程（主容器）之外的工作